CREATE DATABASE final_project;
USE final_project;
DROP TABLE IF EXISTS accounts;
CREATE TABLE accounts (
    id INT AUTO_INCREMENT PRIMARY KEY,
    owner VARCHAR(50),
    balance DECIMAL(10,2)
);
INSERT INTO accounts (owner, balance) VALUES ('Nuha', 1000.00), ('Dina', 1000.00);

DROP TABLE IF EXISTS three_phase_log;
CREATE TABLE three_phase_log (
    tx_id VARCHAR(50),
    state VARCHAR(20),
    saved_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

DROP TABLE IF EXISTS chain_ledger;
CREATE TABLE chain_ledger (
    block_id INT AUTO_INCREMENT PRIMARY KEY,
    tx_data TEXT,
    prev_hash VARCHAR(64),
    curr_hash VARCHAR(64),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

DELIMITER $$

DROP PROCEDURE IF EXISTS simulate_2pc$$

CREATE PROCEDURE simulate_2pc(IN sender VARCHAR(50), IN amount DECIMAL(10,2), IN crash_switch BOOLEAN)
BEGIN
    DECLARE current_bal DECIMAL(10,2);
    
    START TRANSACTION;
    SELECT balance INTO current_bal FROM accounts WHERE owner = sender FOR UPDATE;

    IF crash_switch THEN
        DO SLEEP(5); 
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'SYSTEM CRASH: Resources left locked (Blocking Problem)';
    ELSE
        UPDATE accounts SET balance = balance - amount WHERE owner = sender;
        COMMIT;
        SELECT 'Transaction Successful' AS status;
    END IF;
END$$

DELIMITER ;

DELIMITER $$

DROP PROCEDURE IF EXISTS simulate_3pc$$

CREATE PROCEDURE simulate_3pc(IN sender VARCHAR(50), IN amount DECIMAL(10,2))
BEGIN
    DECLARE new_tx_id VARCHAR(50);
    SET new_tx_id = UUID();

    START TRANSACTION;
    
    -- Write to Log FIRST (The Safety Net)
    INSERT INTO three_phase_log (tx_id, state) VALUES (new_tx_id, 'PRE_COMMIT');
    
    -- Then do the work
    UPDATE accounts SET balance = balance - amount WHERE owner = sender;
    
    -- Finish
    UPDATE three_phase_log SET state = 'COMMITTED' WHERE tx_id = new_tx_id;
    COMMIT;
    
    SELECT * FROM three_phase_log WHERE tx_id = new_tx_id;
END$$

DELIMITER ;

DELIMITER $$

DROP PROCEDURE IF EXISTS simulate_blockchain$$

CREATE PROCEDURE simulate_blockchain(IN sender VARCHAR(50), IN amount DECIMAL(10,2))
BEGIN
    DECLARE last_hash VARCHAR(64);
    DECLARE new_hash VARCHAR(64);
    DECLARE data_string TEXT;

    -- 1. Get the last hash
    SELECT curr_hash INTO last_hash FROM chain_ledger ORDER BY block_id DESC LIMIT 1;
    
    IF last_hash IS NULL THEN
        SET last_hash = '00000000000000000000000000000000'; 
    END IF;

    -- 2. Create Hash
    SET data_string = CONCAT(sender, ' sent ', amount, ' | Prev: ', last_hash);
    SET new_hash = SHA2(data_string, 256);

    -- 3. Save
    INSERT INTO chain_ledger (tx_data, prev_hash, curr_hash) 
    VALUES (data_string, last_hash, new_hash);

    -- 4. Show the chain
    SELECT tx_data, prev_hash, curr_hash FROM chain_ledger ORDER BY block_id DESC LIMIT 2;
END$$

DELIMITER ;


-- ==========================================
-- FAILURE SIMULATION: NETWORK DISCONNECT
-- ==========================================
-- Setup initial state 
CREATE DATABASE testdb;
\c testdb
CREATE TABLE accounts (id INT PRIMARY KEY, balance INT);
INSERT INTO accounts VALUES (1, 1000);

-- Initiate and Prepare Transaction 
XA START 'tx_2pc_demo;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
XA END 'tx_2pc_demo';
XA PREPARE 'tx_2pc_demo';

-- After simulated network adapter disconnect 
-- Verify Prepared State remains active and unresolved 
XA RECOVER;

-- Resolve Transaction
XA ROLLBACK 'tx_2pc_demo';

-- ==========================================
-- FAILURE SIMULATION: DATABASE CRASH
-- ==========================================
-- Setup vault table 
CREATE TABLE IF NOT EXISTS vault (id INT PRIMARY KEY, gold INT);
INSERT INTO vault (id, gold) VALUES (1, 1000) ON CONFLICT (id) DO UPDATE SET gold = EXCLUDED.gold;

-- Enter Prepared State before crash 
USE xa_test;
XA START 'xid-001';
UPDATE accounts SET balance = balance - 10 WHERE id = 1;
XA END 'xid-001';
XA PREPARE 'xid-001';

-- Blocked query in separate session
USE xa_test;

-- Simulate crash by stopping PostgreSQL service 
-- After restart, verify durability via WAL 
XA RECOVER;

-- Resolve transaction
XA COMMIT 'xid-001';

-- ==================================================
-- FAILURE SIMULATION: FORCE INCOMPLETE TRANSACTION
-- ==================================================
-- 1. Setup: Create a test database and InnoDB table 
CREATE DATABASE IF NOT EXISTS xa_test; USE xa_test; 
USE xa_test;
DROP TABLE IF EXISTS accounts;  
CREATE TABLE accounts ( id INT PRIMARY KEY, balance INT NOT NULL ) ENGINE=InnoDB; 

-- 2. Insert initial data  
INSERT INTO accounts (id, balance) VALUES (1, 100) ON DUPLICATE KEY UPDATE balance = VALUES(balance); 

-- 3. Session A: Initiate and Prepare XA Transaction 
USE xa_test;
XA START 'xid-001'; 
UPDATE accounts SET balance = balance - 10 WHERE id = 1; 
XA END 'xid-001'; 
XA PREPARE 'xid-001'; 

-- 4. Session B: Attempt modification (Verification of Locking) 
-- This query will block and eventually timeout 
USE xa_test;
UPDATE accounts SET balance = balance + 20 WHERE id = 1; 
-- Expected Output: ERROR 1205 (HY000): Lock wait timeout exceeded 

-- 5. Simulate Failure: Kill MySQL process via Command Prompt 
-- net stop MySQL80 
-- net start MySQL80 

-- 6. Verification & Recovery: Check in-doubt transactions after restart 
XA RECOVER; 

-- 7. Finalize the transaction manually 
XA COMMIT 'xid-001'; 

-- 8. Verify final balance 
SELECT * FROM accounts WHERE id = 1;
